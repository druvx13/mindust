<?php
// CSRF Protection Helper Functions

if (session_status() === PHP_SESSION_NONE) {
    session_start();
}

/**
 * Generates a CSRF token, stores it in the session, and returns it.
 * If a token already exists in the session, it returns that token
 * unless forced to regenerate.
 *
 * @param bool $force_regenerate If true, a new token will be generated even if one exists.
 * @return string The CSRF token.
 */
function generate_csrf_token($force_regenerate = false): string {
    if (!$force_regenerate && isset($_SESSION['csrf_token'])) {
        return $_SESSION['csrf_token'];
    }

    try {
        $token = bin2hex(random_bytes(32));
        $_SESSION['csrf_token'] = $token;
        return $token;
    } catch (Exception $e) {
        // Fallback if random_bytes fails (highly unlikely for modern PHP)
        error_log("CSRF token generation failed (random_bytes): " . $e->getMessage());
        $token = sha1(uniqid(mt_rand(), true)); // Less secure fallback
        $_SESSION['csrf_token'] = $token;
        return $token;
    }
}

/**
 * Verifies a submitted CSRF token against the one stored in the session.
 *
 * @param string|null $submitted_token The token submitted with the form.
 * @return bool True if the token is valid, false otherwise.
 */
function verify_csrf_token(?string $submitted_token): bool {
    if (empty($submitted_token) || !isset($_SESSION['csrf_token'])) {
        return false;
    }

    $result = hash_equals($_SESSION['csrf_token'], $submitted_token);

    // It's good practice to use tokens only once.
    // For simplicity in this implementation, we might reuse the token for the session duration,
    // or regenerate it after successful verification if forms are on different pages.
    // For now, let's unset it after verification to make it a one-time token for that specific form submission.
    // This means generate_csrf_token() will create a new one for the next form.
    if ($result) {
       // unset($_SESSION['csrf_token']); // Option 1: One-time use per verification
       // generate_csrf_token(true); // Option 2: Regenerate after use for next form
       // For this project, let's keep it simple: token is valid for session, regen on demand.
       // The form display should call generate_csrf_token() each time to ensure it's fresh if needed.
    }

    return $result;
}

/**
 * Outputs a hidden input field with the CSRF token.
 * Call this function inside your HTML forms.
 * Make sure to call generate_csrf_token() before rendering the form
 * so the token is available in the session and returned by this function.
 */
function csrf_input_field(): void {
    $token = $_SESSION['csrf_token'] ?? ''; // Get current token, should be generated by generate_csrf_token() before form display
    if (empty($token)) {
        // This case should ideally not happen if generate_csrf_token() is called before form display.
        // For safety, generate one now if it's missing.
        $token = generate_csrf_token(true);
    }
    echo '<input type="hidden" name="csrf_token" value="' . htmlspecialchars($token) . '">';
}

?>
